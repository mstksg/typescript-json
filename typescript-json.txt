-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub.
@package typescript-json
@version 0.1.0.0


-- | Invariant "Functor combinators" (a la <a>Data.Functor.Combinator</a>)
--   used for type definitions.
module Typescript.Json.Types.Combinators

-- | Give <tt>f</tt> an <a>Invariant</a> instance, except the post-map can
--   be partial. PS stands for parser-and-serializer: With a <tt><a>PS</a>
--   f a</tt>, you can serialize an <tt>a</tt> using it (total), or you can
--   parse an <tt>a</tt> out of it (partial, with a <a>Text</a> error).
data PS f a
PS :: f r -> (r -> Either Text a) -> (a -> r) -> PS f a
[psItem] :: PS f a -> f r
[psParser] :: PS f a -> r -> Either Text a
[psSerializer] :: PS f a -> a -> r

-- | If <tt>h a</tt> is some sort of witness on <tt>a</tt>, then <tt>ILan g
--   h a</tt> essentially turns it into a witness on <tt>g a</tt>.
--   
--   It's used twice in the library: with <tt>[]</tt>, it turns <tt>F
--   a</tt>, a serializer<i>parser on <tt>a</tt>, into <tt>ILan [] F
--   [a]</tt>, a serializer</i>parser on <tt>[a]</tt>, a list of them. It
--   also does the same thing with <tt>Maybe</tt>, for optional parsers.
--   
--   For all of the functions here, it's generally more understandable when
--   you substitute a specific functor in for <tt>g</tt>.
--   
--   Construct using <a>ilan</a>, usually.
data ILan g h a
ILan :: (g x -> a) -> (a -> g x) -> h x -> ILan g h a

-- | Given a witness <tt>h a</tt>, turn it into a witness <tt>h (g a)</tt>
--   using <a>ILan</a>.
ilan :: h a -> ILan g h (g a)

-- | Interpret <a>ILan</a> into any invariant context, within its "lifted"
--   witness.
--   
--   For example, for <tt><a>ILan</a> []</tt>, its type is:
--   
--   <pre>
--   (forall x. h x -&gt; f [x])
--     -&gt; ILan g h a
--     -&gt; f a
--   </pre>
--   
--   If you can interpret <tt>h x</tt> into a list of <tt>x</tt> in some
--   context, then it interprets out the <tt>a</tt>.
interpretILan :: Invariant f => (forall x. h x -> f (g x)) -> ILan g h a -> f a

-- | Interpret <a>ILan</a>, but requiring only a <a>Functor</a> context.
interpretCoILan :: Functor f => (forall x. h x -> f (g x)) -> ILan g h a -> f a

-- | Interpret <a>ILan</a>, but requiring only a <a>Contravariant</a>
--   context.
interpretContraILan :: Contravariant f => (forall x. h x -> f (g x)) -> ILan g h a -> f a

-- | Invariant Coyoneda: the "free invariant functor". Gives any <tt>f</tt>
--   and <a>Invariant</a> instance.
data ICoyoneda f a
ICoyoneda :: (a -> r) -> (r -> a) -> f r -> ICoyoneda f a

-- | Strip out the covariant aspect of an invariant coyoneda to leave the
--   contravariant part.
icoToContraco :: ICoyoneda f ~> Coyoneda f

-- | Strip out the contravariant aspect of an invariant coyoneda to leave
--   the covariant part.
icoToCoco :: ICoyoneda f ~> Coyoneda f
data MP :: (k -> Type) -> Maybe k -> Type
[MPNothing] :: MP f 'Nothing
[MPJust] :: f a -> MP f ('Just a)
data NP2 :: (k -> j -> Type) -> [k] -> [j] -> Type
[Nil2] :: NP2 f '[] '[]
[:**] :: f a b -> NP2 f as bs -> NP2 f (a : as) (b : bs)
infixr 5 :**
hmap2 :: forall f g as bs. (forall a b. f a b -> g a b) -> NP2 f as bs -> NP2 g as bs
htraverse2 :: forall f g h as bs. Applicative h => (forall a b. f a b -> h (g a b)) -> NP2 f as bs -> h (NP2 g as bs)
hfoldMap2 :: forall f m as bs. Monoid m => (forall a b. f a b -> m) -> NP2 f as bs -> m
np2Left :: forall f g as bs. (forall a b. f a b -> g a) -> NP2 f as bs -> NP g as
splitAp :: forall f b. Ap f b -> [Some f]
findNP :: forall f g as. () => (forall a. f a -> Maybe (g a)) -> NP f as -> Maybe (NS g as)
instance Data.HFunctor.Internal.HFunctor Typescript.Json.Types.Combinators.MP
instance Data.HFunctor.HTraversable.HTraversable Typescript.Json.Types.Combinators.MP
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.Combinators.ICoyoneda f)
instance Data.HFunctor.Internal.HFunctor Typescript.Json.Types.Combinators.ICoyoneda
instance Data.HFunctor.HTraversable.HTraversable Typescript.Json.Types.Combinators.ICoyoneda
instance Data.HFunctor.Inject Typescript.Json.Types.Combinators.ICoyoneda
instance Data.Functor.Invariant.Invariant f => Data.HFunctor.Interpret.Interpret Typescript.Json.Types.Combinators.ICoyoneda f
instance forall k (g :: k -> *) (h :: k -> *). Data.Functor.Invariant.Invariant (Typescript.Json.Types.Combinators.ILan g h)
instance forall k (g :: k -> *). Data.HFunctor.Internal.HFunctor (Typescript.Json.Types.Combinators.ILan g)
instance forall k (g :: k -> *). Data.HFunctor.HTraversable.HTraversable (Typescript.Json.Types.Combinators.ILan g)
instance forall k (g :: k -> *). Data.HFunctor.HTraversable.HTraversable1 (Typescript.Json.Types.Combinators.ILan g)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.Combinators.PS f)
instance Data.HFunctor.Internal.HFunctor Typescript.Json.Types.Combinators.PS
instance Data.HFunctor.Inject Typescript.Json.Types.Combinators.PS

module Typescript.Json.Types.Sing
type family Length (as :: [k]) :: Nat
data SNat_ :: Nat -> Type
[SZ_] :: SNat_ 'Z
[SS_] :: SNat_ n -> SNat_ ('S n)
plusNat :: SNat_ as -> SNat_ bs -> SNat_ (Plus as bs)
vecToSNat_ :: forall n b. Vec n b -> SNat_ n
prodVec :: forall f as b. (forall a. f a -> b) -> NP f as -> Vec (Length as) b
prodVec2 :: forall f as bs c. (forall a b. f a b -> c) -> NP2 f as bs -> Vec (Length as) c
shiftFin :: forall as bs. () => SNat_ as -> Fin bs -> Fin (Plus as bs)
weakenFin :: forall as bs. () => Fin as -> Fin (Plus as bs)
assocPlus :: forall a b c. () => SNat_ a -> Plus a (Plus b c) :~: Plus (Plus a b) c
commutePlus :: forall a b. () => SNat_ a -> SNat_ b -> Plus a b :~: Plus b a
rightSuccPlus :: SNat_ a -> SNat_ b -> 'S (Plus a b) :~: Plus a ('S b)
zeroPlus :: SNat_ a -> a :~: Plus a 'Z
vecSame :: Vec n a -> Vec m a -> Maybe (n :~: m)
data SSym :: Symbol -> Type
[SSym] :: KnownSymbol s => SSym s
ssymToText :: SSym s -> Text
withSSym :: Text -> (forall s. SSym s -> r) -> r
instance Data.Type.Equality.TestEquality Typescript.Json.Types.Sing.SSym

module Typescript.Json.Types
data TSPrim :: Type -> Type
[TSNumber] :: TSPrim Scientific
[TSBigInt] :: TSPrim Integer
[TSString] :: TSPrim Text
[TSUnknown] :: TSPrim Value
[TSAny] :: TSPrim Value

-- | <a>Named</a> primitive types, that cannot be anonymous
data TSNamedBase :: Type -> Type
[TSEnum] :: Vec n (Text, EnumLit) -> TSNamedBase (Fin n)
data TSBase :: Type -> Type
[TSBoolean] :: TSBase Bool
[TSStringLit] :: Text -> TSBase ()
[TSNumericLit] :: Scientific -> TSBase ()
[TSBigIntLit] :: Integer -> TSBase ()
[TSVoid] :: TSBase ()
[TSUndefined] :: TSBase ()
[TSNull] :: TSBase ()
[TSNever] :: TSBase Void
data EnumLit
ELString :: Text -> EnumLit
ELNumber :: Scientific -> EnumLit
data TSType :: Nat -> IsObjType -> Type -> Type
[TSArray] :: ILan [] (TSType p k) a -> TSType p 'NotObj a
[TSTuple] :: PreT Ap (TSType_ p) a -> TSType p 'NotObj a
[TSObject] :: TSKeyVal p a -> TSType p 'IsObj a
[TSSingle] :: TSType p 'IsObj a -> TSType p 'NotObj a
[TSUnion] :: TSUnionBranches p a -> TSType p 'NotObj a
[TSNamedType] :: TSApplied p k a -> TSType p k a
[TSVar] :: !Fin p -> TSType p 'NotObj a
[TSIntersection] :: PreT Ap1 (TSType p 'IsObj) a -> TSType p 'IsObj a
[TSTransformType] :: ICoyoneda (TSTransform p k) a -> TSType p k a
[TSPrimType] :: PS TSPrim a -> TSType p 'NotObj a
[TSBaseType] :: ICoyoneda TSBase a -> TSType p 'NotObj a
data TSType_ p a
TSType_ :: TSType p k a -> TSType_ p a
[unTSType_] :: TSType_ p a -> TSType p k a
data TSNamed p k as es a
TSNamed :: Text -> TSNameable p k as es a -> TSNamed p k as es a
[tsnName] :: TSNamed p k as es a -> Text
[tsnType] :: TSNamed p k as es a -> TSNameable p k as es a
data TSNamed_ p as es a
TSNamed_ :: TSNamed p k as es a -> TSNamed_ p as es a
withTSNamed_ :: (forall k. TSNamed p k as es a -> r) -> TSNamed_ p as es a -> r
newtype Assign a b
Assign :: (a -> Either Text b) -> Assign a b
[runAssign] :: Assign a b -> a -> Either Text b
data TSNameable :: Nat -> IsObjType -> [Type] -> [Maybe Type] -> Type -> Type
[TSNFunc] :: TSTypeF p k as es a -> TSNameable p k as es a
[TSNBaseType] :: ICoyoneda TSNamedBase a -> TSNameable p 'NotObj '[] '[] a
data Param p a b
Param :: Text -> MP (TSType_ p) b -> Param p a b
[paramName] :: Param p a b -> Text
[paramExtends] :: Param p a b -> MP (TSType_ p) b
data Arg p k a b
Arg :: TSType p k a -> MP (Assign a) b -> Arg p k a b
[argType] :: Arg p k a b -> TSType p k a
[argAssign] :: Arg p k a b -> MP (Assign a) b
data Arg_ p a b
Arg_ :: Arg p k a b -> Arg_ p a b
withArg_ :: (forall k. Arg p k a e -> r) -> Arg_ p a e -> r
data ObjMember f a
ObjMember :: Mutability -> Text -> (f :+: ILan Maybe f) a -> ObjMember f a
[objMemberReadOnly] :: ObjMember f a -> Mutability
[objMemberKey] :: ObjMember f a -> Text
[objMemberVal] :: ObjMember f a -> (f :+: ILan Maybe f) a
data Mutability
Mutable :: Mutability
ReadOnly :: Mutability

-- | Built-in named type transformers in typescript, that should be
--   displayed as such when printed.
data TSTransform :: Nat -> IsObjType -> Type -> Type
[TSPartial] :: TSType p 'IsObj a -> TSTransform p 'IsObj (Maybe a)
[TSReadOnly] :: TSType p 'IsObj a -> TSTransform p 'IsObj a
[TSPickPartial] :: TSType p 'IsObj a -> TSType p 'NotObj (KeySubset ks a) -> Assign (KeySubset ks a) (KeyOf ks a) -> TSTransform p 'IsObj (Maybe a)
[TSOmitPartial] :: TSType p 'IsObj a -> TSType p 'NotObj (KeySubset ks a) -> Assign (KeySubset ks a) (KeyOf ks a) -> TSTransform p 'IsObj (Maybe a)
[TSStringManipType] :: TSStringManip -> TSType p 'NotObj a -> Assign a ExtendsString -> TSTransform p 'NotObj a
data TSStringManip
TSUppercase :: TSStringManip
TSLowercase :: TSStringManip
TSCapitalize :: TSStringManip
TSUncapitalize :: TSStringManip
newtype ExtendsString
ExtendsString :: Text -> ExtendsString
[getExtendsString] :: ExtendsString -> Text

-- | Canonical type to test against when using TSStringManipType
extendsString :: TSType p 'NotObj ExtendsString

-- | Transforms are just deferred evaluations of functions. here they are
--   actually applied
applyTransform :: TSTransform p k a -> TSType p k a
type TSKeyVal p = PreT Ap (ObjMember (TSType_ p))
type TSUnionBranches p = DecAlt1 (TSType_ p)
mapTSType_ :: (forall k. TSType p k a -> TSType us k b) -> TSType_ p a -> TSType_ us b
withTSType_ :: (forall k. TSType p k a -> r) -> TSType_ p a -> r
onTSType_ :: (TSType p 'NotObj a -> r) -> (TSType p 'IsObj a -> r) -> TSType_ p a -> r
decideTSType_ :: TSType_ p ~> (TSType p 'NotObj :+: TSType p 'IsObj)
data IsObjType
NotObj :: IsObjType
IsObj :: IsObjType
data SIsObjType :: IsObjType -> Type
[SNotObj] :: SIsObjType 'NotObj
[SIsObj] :: SIsObjType 'IsObj
data SNat_ :: Nat -> Type
[SZ_] :: SNat_ 'Z
[SS_] :: SNat_ n -> SNat_ ('S n)
interpretObjMember :: Invariant g => (Mutability -> Text -> f ~> g) -> (forall x. Mutability -> Text -> f x -> g (Maybe x)) -> ObjMember f ~> g
tsObjType :: TSType p k a -> SIsObjType k
collapseIsObj :: TSType p 'IsObj a -> TSKeyVal p a
splitKeyVal :: TSKeyVal p a -> Map Text (Some (Pre a (TSType_ p)))
isObjKeys :: TSType p 'IsObj a -> Set Text
mkNullable :: TSType p k a -> TSType p 'NotObj (Maybe a)
toVarArgs :: forall p as es. () => NP2 (Param p) as es -> (SNat_ (Length as), NP2 (Arg_ (Plus (Length as) p)) as es)
data TSTypeF :: Nat -> IsObjType -> [Type] -> [Maybe Type] -> Type -> Type
[TSGeneric] :: NP2 (Param p) as es -> (forall r. SNat_ r -> NP2 (Arg_ (Plus r p)) as es -> TSType (Plus r p) k b) -> TSTypeF p k as es b
[TSGenericInterface] :: NP2 (Param p) as es -> (a -> b -> c) -> (c -> (a, b)) -> Lift (TSAppliedF p 'IsObj as es) a -> (forall r. SNat_ r -> NP2 (Arg_ (Plus r p)) as es -> TSKeyVal (Plus r p) b) -> TSTypeF p 'IsObj as es c
data TSTypeF_ p as es b
TSTypeF_ :: TSTypeF p k as es b -> TSTypeF_ p as es b
[unTSTypeF_] :: TSTypeF_ p as es b -> TSTypeF p k as es b
data TSApplied p k a
(:$) :: TSNamed p k as es a -> NP2 (Arg_ p) as es -> TSApplied p k a
[tsaFunc] :: TSApplied p k a -> TSNamed p k as es a
[tsaArgs] :: TSApplied p k a -> NP2 (Arg_ p) as es
data TSAppliedF p k as es a
(:?) :: TSNamed p k bs ds a -> NP2 (ArgF_ p as es) bs ds -> TSAppliedF p k as es a
[tsafFunc] :: TSAppliedF p k as es a -> TSNamed p k bs ds a
[tsafArgs] :: TSAppliedF p k as es a -> NP2 (ArgF_ p as es) bs ds
data ArgF p k as es a e
ArgF :: TSTypeF p k as es a -> MP (Assign a) e -> ArgF p k as es a e
[argfType] :: ArgF p k as es a e -> TSTypeF p k as es a
[argfAssign] :: ArgF p k as es a e -> MP (Assign a) e
data ArgF_ p as es a e
ArgF_ :: ArgF p k as es a e -> ArgF_ p as es a e
withArgF_ :: (forall k. ArgF p k as es a e -> r) -> ArgF_ p as es a e -> r
mapTSTypeF_ :: (forall k. TSTypeF p k as es b -> TSTypeF q k as' es' b') -> TSTypeF_ p as es b -> TSTypeF_ q as' es' b'
withTSTypeF_ :: (forall k. TSTypeF p k as es b -> r) -> TSTypeF_ p as es b -> r
pattern Param' :: Text -> Param p a 'Nothing
pattern Arg' :: TSType p k a -> Arg p k a 'Nothing
data ParseErr
PEInvalidEnum :: [(Text, EnumLit)] -> ParseErr
PEInvalidString :: Text -> Text -> ParseErr
PEInvalidNumber :: Scientific -> Scientific -> ParseErr
PEInvalidBigInt :: Integer -> Integer -> ParseErr
PEPrimitive :: Some TSPrim -> Text -> ParseErr
PEExtraTuple :: Int -> Int -> ParseErr
PENotInUnion :: NonEmpty (Doc ()) -> ParseErr
PENever :: ParseErr
tsApply :: TSTypeF p k as es b -> NP2 (Arg_ p) as es -> TSType p k b
tsApply1 :: TSTypeF p k '[a] '[e] b -> Arg_ p a e -> TSType p k b
tsApplyF :: forall p k as es bs ds b. TSTypeF p k as es b -> NP2 (ArgF_ p bs ds) as es -> NP2 (Arg_ p) bs ds -> TSType p k b

-- | Apply a TypeF with free variables
tsApplyVar :: forall p k as es b. () => TSTypeF p k as es b -> TSType (Plus (Length as) p) k b
tsfParams :: TSTypeF p k as es b -> Vec (Length as) Text
tsShift :: forall r p k a. () => SNat_ r -> TSType p k a -> TSType (Plus r p) k a
shiftApplied :: SNat_ r -> TSApplied p k a -> TSApplied (Plus r p) k a
shiftAppliedF :: SNat_ r -> TSAppliedF p k as es a -> TSAppliedF (Plus r p) k as es a
shiftNameable :: SNat_ r -> TSNameable p k as es a -> TSNameable (Plus r p) k as es a
shiftTypeF :: forall r p k as es a. SNat_ r -> TSTypeF p k as es a -> TSTypeF (Plus r p) k as es a

-- | Pulls out the (x | y | z) from (x | y | z) | null. The result is an
--   <a>ILan</a> where the item inside is non-nullable.
--   
--   This removes ALL nulls and undefineds.
--   
--   Note that, if the result is Just (it is nullable), this inlines all
--   named times because it changes the structure of the type itself.
isNullable :: TSType p k a -> Maybe (ILan Maybe (TSType p 'NotObj) a)
flattenUnion :: TSType p k a -> DecAlt1 (TSType_ p) a

-- | If the type is a singleton type with only one inhabitant, this gives
--   that type.
singletonValue :: TSType p k a -> Maybe a

-- | Summon some example values
summonValues :: TSType p k a -> [a]
data KeyOf ks a
KeyOf :: NS SSym ks -> KeyOf ks a
[getKeyOf] :: KeyOf ks a -> NS SSym ks
newtype KeySubset ks a
KeySubset :: NP (Maybe :.: SSym) ks -> KeySubset ks a
[getKeySubset] :: KeySubset ks a -> NP (Maybe :.: SSym) ks
keyOf :: TSType p 'IsObj a -> (forall ks. NP SSym ks -> TSType p 'NotObj (KeyOf ks a) -> r) -> r
data KeySubsetErr
KSEUnmatched :: NonEmpty Text -> KeySubsetErr
KSENoMatches :: KeySubsetErr
mkKeySubset :: forall ks a p. () => Set Text -> NP SSym ks -> Either KeySubsetErr (TSType p 'NotObj (KeySubset ks a), Assign (KeySubset ks a) (KeyOf ks a))
instance GHC.Show.Show Typescript.Json.Types.ParseErr
instance GHC.Enum.Bounded Typescript.Json.Types.Mutability
instance GHC.Enum.Enum Typescript.Json.Types.Mutability
instance GHC.Generics.Generic Typescript.Json.Types.Mutability
instance GHC.Classes.Ord Typescript.Json.Types.Mutability
instance GHC.Classes.Eq Typescript.Json.Types.Mutability
instance GHC.Show.Show Typescript.Json.Types.Mutability
instance GHC.Classes.Ord Typescript.Json.Types.EnumLit
instance GHC.Classes.Eq Typescript.Json.Types.EnumLit
instance GHC.Show.Show Typescript.Json.Types.EnumLit
instance GHC.Show.Show (Typescript.Json.Types.TSPrim a)
instance GHC.Classes.Eq (Typescript.Json.Types.TSPrim a)
instance GHC.Classes.Ord (Typescript.Json.Types.TSPrim a)
instance GHC.Show.Show (Typescript.Json.Types.TSNamedBase a)
instance GHC.Classes.Eq (Typescript.Json.Types.TSNamedBase a)
instance GHC.Classes.Ord (Typescript.Json.Types.TSNamedBase a)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSNamed_ p as es)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSTypeF_ p as es)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSType_ p)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSNameable p k as es)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSNamed p k as es)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSTypeF p k as es)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Types.TSType p k)
instance Data.HFunctor.Internal.HFunctor Typescript.Json.Types.ObjMember
instance Data.HFunctor.HTraversable.HTraversable Typescript.Json.Types.ObjMember
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Typescript.Json.Types.ObjMember f)
instance Data.GADT.Internal.GShow Typescript.Json.Types.TSNamedBase
instance Data.GADT.Internal.GShow Typescript.Json.Types.TSPrim

module Typescript.Json.Primitive
tsBoolean :: TSType p 'NotObj Bool
tsNumber :: TSType p 'NotObj Scientific
tsBoundedInteger :: (Integral a, Bounded a) => TSType p 'NotObj a
tsInteger :: Integral a => TSType p 'NotObj a
tsRealFloat :: RealFloat a => TSType p 'NotObj a
tsDouble :: TSType p 'NotObj Double
tsBigInt :: TSType p 'NotObj Integer
tsText :: TSType p 'NotObj Text
tsLazyText :: TSType p 'NotObj Text
tsString :: TSType p 'NotObj String
tsStringLit :: Text -> TSType p 'NotObj ()
tsNumericLit :: Scientific -> TSType p 'NotObj ()
tsIntegerLit :: Integral a => a -> TSType p 'NotObj ()
tsBigIntLit :: Integer -> TSType p 'NotObj ()
tsUnknown :: TSType p 'NotObj Value
tsAny :: TSType p 'NotObj Value
tsVoid :: TSType p 'NotObj ()
tsUndefined :: TSType p 'NotObj ()
tsNull :: TSType p 'NotObj ()
tsNever :: TSType p 'NotObj Void

module Typescript.Json.Parameterized

-- | A parameterized type with multiple parameters.
tsGeneric :: Text -> NP2 (Param p) as es -> (forall r. SNat_ r -> NP2 (Arg_ (Plus r p)) as es -> TSType (Plus r p) k b) -> TSNamed p k as es b

-- | Create a single-argument generic (parameterized) type.
--   
--   For example, we could make a type imitating <a>Maybe</a> in Haskell:
--   
--   <pre>
--   mkMaybe :: TSType_ p a -&gt; TSType_ p (Maybe a)
--   mkMaybe = tsUnion $ decide (maybe (Left ()) Right) $
--       (tsTagged
--   </pre>
tsGeneric1 :: Text -> Param p a e -> (forall r. SNat_ r -> Arg_ (Plus r p) a e -> TSType (Plus r p) k b) -> TSNamed p k '[a] '[e] b
tsGeneric2 :: Text -> Param p a ea -> Param p b eb -> (forall r. SNat_ r -> Arg_ (Plus r p) a ea -> Arg_ (Plus r p) b eb -> TSType (Plus r p) k c) -> TSNamed p k '[a, b] '[ea, eb] c
tsGeneric3 :: Text -> Param p a ea -> Param p b eb -> Param p c ec -> (forall r. SNat_ r -> Arg_ (Plus r p) a ea -> Arg_ (Plus r p) b eb -> Arg_ (Plus r p) c ec -> TSType (Plus r p) k d) -> TSNamed p k '[a, b, c] '[ea, eb, ec] d
tsGenericInterface :: Text -> NP2 (Param p) as es -> Lift (TSAppliedF p 'IsObj as es) a -> (forall r. SNat_ r -> NP2 (Arg_ (Plus r p)) as es -> TSKeyVal (Plus r p) b) -> TSNamed p 'IsObj as es (a, b)
tsApplied1 :: TSNamed p k '[a] '[e] b -> Arg_ p a e -> TSType p k b
tsApplied2 :: TSNamed p k '[a, b] '[ea, eb] c -> Arg_ p a ea -> Arg_ p b eb -> TSType p k c
tsApplied3 :: TSNamed p k '[a, b, c] '[ea, eb, ec] d -> Arg_ p a ea -> Arg_ p b eb -> Arg_ p c ec -> TSType p k d
tsApplied :: TSNamed p k as es b -> NP2 (Arg_ p) as es -> TSType p k b
tsApply1 :: TSTypeF p k '[a] '[e] b -> Arg_ p a e -> TSType p k b
tsApply2 :: TSTypeF p k '[a, b] '[ea, eb] c -> Arg_ p a ea -> Arg_ p b eb -> TSType p k c
tsApply3 :: TSTypeF p k '[a, b, c] '[ea, eb, ec] d -> Arg_ p a ea -> Arg_ p b eb -> Arg_ p c ec -> TSType p k d
tsApply :: TSTypeF p k as es b -> NP2 (Arg_ p) as es -> TSType p k b

module Typescript.Json.Enum
data FinIso n a
FinIso :: (Fin n -> a) -> (a -> Fin n) -> FinIso n a
[fiGet] :: FinIso n a -> Fin n -> a
[fiPut] :: FinIso n a -> a -> Fin n
tsEnumWith :: Text -> FinIso n a -> Vec n (Text, EnumLit) -> TSNamed p 'NotObj '[] '[] a
tsIntEnumFrom :: Text -> Int -> FinIso n a -> Vec n Text -> TSNamed p 'NotObj '[] '[] a
tsIntEnum :: Text -> FinIso n a -> Vec n Text -> TSNamed p 'NotObj '[] '[] a
data EnumMap a
EnumMap :: Map EnumLit (Text, a) -> (a -> EnumLit) -> EnumMap a
[emGet] :: EnumMap a -> Map EnumLit (Text, a)
[emPut] :: EnumMap a -> a -> EnumLit
tsEnumMap :: Text -> EnumMap a -> TSNamed p 'NotObj '[] '[] a
tsFinEnum :: Enum a => Text -> Vec (EnumSize a) (Text, EnumLit) -> TSNamed p 'NotObj '[] '[] a
tsFinIntEnum :: Enum a => Text -> Vec (EnumSize a) Text -> TSNamed p 'NotObj '[] '[] a
instance Data.Functor.Invariant.Invariant (Typescript.Json.Enum.FinIso n)

module Typescript.Json.Core.Encode
enumLitToValue :: EnumLit -> Value
primToValue :: TSPrim a -> a -> Value
typeToValue :: TSType 'Z k a -> a -> Value
encodeEnumLit :: EnumLit -> Encoding
primToEncoding :: TSPrim a -> a -> Encoding
typeToEncoding :: TSType 'Z k a -> a -> Encoding

module Typescript.Json.Collection
tsList :: TSType_ p a -> TSType p 'NotObj [a]
tsVector :: Vector v a => TSType_ p a -> TSType p 'NotObj (v a)
tsIsList :: IsList l => TSType_ p (Item l) -> TSType p 'NotObj l

-- | A type aggregating key-value pairs for an object. Meant to be
--   assembled using <a>keyVal</a> (for required properties) and
--   <a>keyValMay</a> (for optional properties) and combined using its
--   <a>Applicative</a> instance. To finally turn one into a <a>TSType</a>,
--   use <a>tsObject</a>.
--   
--   In a <tt><a>ObjectProps</a> p a b</tt>, the <tt>a</tt> represents the
--   overall aggregate type, and the <tt>b</tt> represents the type of the
--   part that this <a>ObjectProps</a> is describing.
--   
--   <pre>
--   data MyType = MyType
--     { mta :: Int
--     , mtb :: Bool
--     , mtc :: Maybe String
--     }
--   
--   myTypeProps :: <a>ObjectProps</a> p MyType MyType
--   myTypeProps = MyType
--     &lt;$&gt; <a>keyVal</a> True mta "mta" (<a>TSType_</a> <tt>tsBoundedInteger</tt>)
--     &lt;*&gt; keyVal True mtb "mtb" (TSType_ <tt>tsBoolean</tt>)
--     &lt;*&gt; <a>keyValMay</a> mtc "mtc" (TSType_ <tt>tsString</tt>)
--   
--   myType :: TSType p 'IsObj MyType
--   myType = tsObject myTypeProps
--   </pre>
--   
--   <pre>
--   ppType myType
--   -- =&gt; { mta: number, mtb: boolean, mtc?: string }
--   </pre>
--   
--   In the above, <tt>keyVal True mta "mta" tsBoundedInteger</tt> has the
--   type <tt>ObjectProps p MyType Int</tt>, showing that it refers to the
--   <tt>Int</tt> field of the <tt>MyType</tt>. The trick to using this is
--   to assemble <a>ObjectProps</a> together using Applicative combinators
--   until the <tt>a</tt> and <tt>b</tt> "match", and the
--   <a>ObjectProps</a> describes the entire value. Then you can use
--   <a>tsObject</a>.
newtype ObjectProps p a b
ObjectProps :: Ap (Pre a (ObjMember (TSType_ p))) b -> ObjectProps p a b
[getObjectProps] :: ObjectProps p a b -> Ap (Pre a (ObjMember (TSType_ p))) b

-- | Create a single key-value pair for an object. If the first argument is
--   <a>True</a>, will try to turn any nullable value into an optional
--   property with non-nullable type if possible. Otherwise, always uses a
--   required property.
keyVal :: Bool -> (a -> b) -> Mutability -> Text -> TSType_ p b -> ObjectProps p a b

-- | Create a single optional key-value pair for an object.
keyValMay :: (a -> Maybe b) -> Mutability -> Text -> TSType_ p b -> ObjectProps p a (Maybe b)

-- | Gather together object properties into a <a>TSType</a>. See
--   <a>ObjectProps</a> for details on how to use this.
tsObject :: ObjectProps p a a -> TSType p 'IsObj a

-- | A type aggregating values in a tuple type. Meant to be assembled using
--   <a>tupleVal</a> and combined using its <a>Applicative</a> instance. To
--   finally turn one into a <a>TSType</a>, use <a>tsTuple</a>.
--   
--   In a <tt><a>TupleVals</a> p a b</tt>, the <tt>a</tt> represents the
--   overall aggregate type, and the <tt>b</tt> represents the type of the
--   part that this <a>TupleVals</a> is describing.
--   
--   <pre>
--   data MyType = MyType
--     { mta :: Int
--     , mtb :: Bool
--     , mtc :: String
--     }
--   
--   myTypeVals :: <a>TupleVals</a> p MyType MyType
--   myTypeVals = MyType
--     &lt;$&gt; <a>tupleVal</a> mta (TSType_ <tt>tsBoundedInteger</tt>)
--     &lt;*&gt; tupleVal mtb (TSType_ <tt>tsBoolean</tt>)
--     &lt;*&gt; tupleVal mtc (TSType_ <tt>tsString</tt>)
--   
--   myType :: TSType p 'NotObj MyType
--   myType = tsTuple myTypeVals
--   </pre>
--   
--   <pre>
--   ppType myType
--   -- =&gt; [number, boolean, string]
--   </pre>
--   
--   In the above, <tt>tupleVal mta tsBoundedInteger</tt> has the type
--   <tt>TupleVals p MyType Int</tt>, showing that it refers to the
--   <tt>Int</tt> field of the <tt>MyType</tt>. The trick to using this is
--   to assemble <a>TupleVals</a> together using Applicative combinators
--   until the <tt>a</tt> and <tt>b</tt> "match", and the <a>TupleVals</a>
--   describes the entire value. Then you can use <a>tsTuple</a>.
--   
--   Note that the order that the <a>Applicative</a> combination matters:
--   it determines the ordering of the tuple.
newtype TupleVals p a b
TupleVals :: Ap (Pre a (TSType_ p)) b -> TupleVals p a b
[getTupleVals] :: TupleVals p a b -> Ap (Pre a (TSType_ p)) b

-- | Create a singleton <a>TupleVals</a>, to be combined with applicative
--   combinators with others.
tupleVal :: (a -> b) -> TSType_ p b -> TupleVals p a b

-- | Gather together tuple values into a <a>TSType</a>. See
--   <a>TupleVals</a> for details on how to use this.
tsTuple :: TupleVals p a a -> TSType p 'NotObj a
stripObjectVals :: ObjectProps p a b -> TupleVals p a b

-- | A type aggregating the parts of an intersection. Meant to be assembled
--   using <a>intersectVal</a> and combined using its <a>Applicative</a>
--   instance. To finally turn one into a <a>TSType</a>, use
--   <a>tsIntersection</a>.
--   
--   In a <tt><a>IntersectVals</a> p a b</tt>, the <tt>a</tt> represents
--   the overall aggregate type, and the <tt>b</tt> represents the type of
--   the part that this <a>IntersectVals</a> is describing.
--   
--   <pre>
--   data MyType = MyType
--     { mta :: Int
--     , mtb :: Bool
--     , mtc :: Maybe String
--     }
--   
--   myType :: TSType p 'IsObj MyType
--   myType = tsObject $ MyType
--     &lt;$&gt; <a>keyVal</a> True mta "mta" (<a>TSType_</a> <tt>tsBoundedInteger</tt>)
--     &lt;*&gt; keyVal True mtb "mtb" (TSType_ <tt>tsBoolean</tt>)
--     &lt;*&gt; <a>keyValMay</a> mtc "mtc" (TSType_ <tt>tsString</tt>)
--   
--   -- { tag: "something" }
--   tagType :: TSType p 'IsObj ()
--   tagType = tagVal "tag" "something"
--   
--   myTaggedType :: IntersectVals p MyType MyType
--   myTaggedType = intersectVal tagType
--               .&gt; intersectVal myType
--   </pre>
--   
--   <pre>
--   ppType $ tsIntersection myTaggedType
--   -- =&gt; { tag: "something" } &amp;  { mta: number, mtb: boolean, mtc?: string }
--   </pre>
--   
--   This works in the same style as <a>TupleVals</a> and
--   <a>ObjectProps</a>, so see those types for more examples of using an
--   <a>Applicative</a> instance.
--   
--   If any of the objects in the intersection have duplicate keys of the
--   same type, the property value from the rightmost branch will be used
--   when decoding.
--   
--   If any of the objects in the intersection have duplicate keys of
--   different types, this describes an invalid typescript type. The
--   behavior of encoding/decoding is undefined; for encoding, the result
--   will most likely not typecheck in typescript. for decoding, the result
--   will most likely fail to parse.
newtype IntersectVals p a b
IntersectVals :: Ap1 (Pre a (TSType p 'IsObj)) b -> IntersectVals p a b
[getIntersectVals] :: IntersectVals p a b -> Ap1 (Pre a (TSType p 'IsObj)) b

-- | Create a singleton <a>IntersectVals</a>, to be combined with
--   applicative combinators with others.
--   
--   Note that the input type must an object literal, indicated by
--   <tt>'<a>IsObj</a></tt>
intersectVal :: (a -> b) -> TSType p 'IsObj b -> IntersectVals p a b

-- | Gather together intersection values into a <a>TSType</a>. See
--   <tt>IntersectionVals</tt> for details on how to use this.
tsIntersection :: IntersectVals p a a -> TSType p 'IsObj a
instance Data.Functor.Bind.Class.Apply (Typescript.Json.Collection.IntersectVals p a)
instance GHC.Base.Functor (Typescript.Json.Collection.IntersectVals p a)
instance GHC.Base.Applicative (Typescript.Json.Collection.TupleVals p a)
instance Data.Functor.Bind.Class.Apply (Typescript.Json.Collection.TupleVals p a)
instance GHC.Base.Functor (Typescript.Json.Collection.TupleVals p a)
instance GHC.Base.Applicative (Typescript.Json.Collection.ObjectProps p a)
instance Data.Functor.Bind.Class.Apply (Typescript.Json.Collection.ObjectProps p a)
instance GHC.Base.Functor (Typescript.Json.Collection.ObjectProps p a)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Collection.IntersectVals p a)
instance Data.Profunctor.Unsafe.Profunctor (Typescript.Json.Collection.IntersectVals p)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Collection.TupleVals p a)
instance Data.Profunctor.Unsafe.Profunctor (Typescript.Json.Collection.TupleVals p)
instance Data.Functor.Invariant.Invariant (Typescript.Json.Collection.ObjectProps p a)
instance Data.Profunctor.Unsafe.Profunctor (Typescript.Json.Collection.ObjectProps p)

module Typescript.Json.Core.Print
ppType :: TSType 'Z k a -> Doc x
ppType_ :: TSType_ 'Z a -> Doc x
ppEnumLit :: EnumLit -> Doc x
ppNamedBase :: Text -> TSNamedBase a -> Doc x
ppNamed :: TSNamed 'Z k as es a -> Doc x
ppNamed_ :: TSNamed_ 'Z as es a -> Doc x
ppNamed' :: Vec p Text -> TSNamed p k as es a -> Doc x
typeExports_ :: TSType_ 'Z a -> Doc x
typeExports :: TSType 'Z k a -> Doc x
typeExports' :: Vec p Text -> TSType p k a -> Doc x
namedTypeExports_ :: TSNamed_ 'Z as es a -> Doc x
namedTypeExports :: TSNamed 'Z k as es a -> Doc x
namedTypeExports' :: Vec p Text -> TSNamed p k as es a -> Doc x
ppMap :: forall x. () => Map Text (Set Text, Doc x) -> Doc x

-- | Pull out all of the named types to be top-level type declarations, and
--   have create a map of all of those declarations.
flattenNamedType :: Vec p Text -> TSNamed p k as es a -> Map Text (Set Text, Doc x)

-- | Ignores the top level type, so why even bother?
flattenType :: Vec p Text -> TSType p k a -> Map Text (Set Text, Doc x)

-- | TODO: stop if it is a recursive reference
flattenType_ :: forall p k a x. () => Vec p Text -> Set Text -> TSType p k a -> State (Map Text (Set Text, Doc x)) (Set Text)

module Typescript.Json.Core.Parse
parseType :: forall k a. () => TSType 'Z k a -> Parse a
showParseErr :: ParseErr -> String
data ParseErr
PEInvalidEnum :: [(Text, EnumLit)] -> ParseErr
PEInvalidString :: Text -> Text -> ParseErr
PEInvalidNumber :: Scientific -> Scientific -> ParseErr
PEInvalidBigInt :: Integer -> Integer -> ParseErr
PEPrimitive :: Some TSPrim -> Text -> ParseErr
PEExtraTuple :: Int -> Int -> ParseErr
PENotInUnion :: NonEmpty (Doc ()) -> ParseErr
PENever :: ParseErr

module Typescript.Json.Core.Assign

-- | answers: is X assignable to Y?
--   
--   
--   <a>https://basarat.gitbook.io/typescript/type-system/type-compatibility</a>
isAssignable :: TSType 'Z k a -> TSType 'Z j b -> Bool

-- | If X is assignable to Y, then convert x to the more general y,
--   potentially losing information.
reAssign :: TSType 'Z k a -> TSType 'Z j b -> Maybe (Assign a b)
unsafeReAssign :: TSType 'Z k a -> TSType 'Z j b -> Assign a b

-- | Completely 100% unsafe, but at least it doesn't require having a type
--   without any free variables
unsafeAssign :: Assign a b
instance Data.Profunctor.Unsafe.Profunctor Typescript.Json.Core.Assign.WrappedAssign
instance GHC.Base.Functor (Typescript.Json.Core.Assign.WrappedAssign a)
instance GHC.Base.Applicative (Typescript.Json.Core.Assign.WrappedAssign a)
instance Data.Functor.Bind.Class.Apply (Typescript.Json.Core.Assign.WrappedAssign a)

module Typescript.Json.Core
mkArg :: Param 'Z a e -> TSType 'Z k a -> Maybe (Arg_ 'Z a e)
mkArgs :: NP2 (Param 'Z) as es -> NP (TSType_ 'Z) as -> Maybe (NP2 (Arg_ 'Z) as es)
unsafeMkArg :: Param 'Z a e -> TSType 'Z k a -> Arg_ 'Z a e
unsafeMkArgs :: NP2 (Param 'Z) as es -> NP (TSType_ 'Z) as -> NP2 (Arg_ 'Z) as es
instance Typescript.Json.Core.SafeMkArgs '[] '[]
instance Typescript.Json.Core.SafeMkArgs as es => Typescript.Json.Core.SafeMkArgs (a : as) ('GHC.Maybe.Nothing : es)

module Typescript.Json.Union

-- | Build up a union type from a <tt>unionBranch</tt>.
tsUnion :: TSUnionBranches p a -> TSType p 'NotObj a
tsUnions :: (a -> NS I (b : bs)) -> NP (Op a) (b : bs) -> NP (TSType_ p) (b : bs) -> TSType p 'NotObj a

-- | A utility for a simple situation of a "tag" key-value pair, where the
--   property value is just a string literal singleton. Often used to
--   simulate discriminated unions in typescript.
--   
--   <pre>
--   ppType . TSType_ . tsObject $
--     tagVal "tag" "something"
--   -- =&gt; { tag: "sometning" }
--   </pre>
--   
--   You can combine this with other properties:
--   
--   <pre>
--   <tt>ppType</tt> . <a>TSType_</a> . <a>tsObject</a> $
--        <a>tagVal</a> "tag" "something"
--     *&gt; <a>keyVal</a> True "contents" id <a>tsBoolean</a>
--   -- =&gt; { tag: "someting", contents: boolean }
--   </pre>
--   
--   See also <a>taggedObject</a>, which uses an intersection instead of
--   joining the keys directly.
tagVal :: Mutability -> Text -> Text -> ObjectProps p a ()

-- | A utility for a simple situation of a "tag" key-value pair intersected
--   with an object type. Often used to simulate discriminated unions in
--   typescript.
--   
--   <pre>
--   <tt>ppType</tt> . <a>TSType_</a> $
--        <a>taggedObject</a> "tag" "something" $
--            <a>tsObject</a> $
--              (,) <a>$</a> <a>keyVal</a> True "name" fst (TSType_ <a>tsText</a>)
--                  <a>*</a> <a>keyVal</a> True "age" snd (TSType_ <a>tsBoundedInteger</a>)
--   -- =&gt; { tag: "something" } &amp; { name: string, age: number }
--   </pre>
--   
--   See also <a>taggedObject</a>, which uses an intersection instead of
--   joining the keys directly.
taggedObject :: Mutability -> Text -> Text -> TSType p 'IsObj a -> TSType p 'IsObj a

-- | High-level utility to wrap a <a>TSType_</a> with a "tag".
--   
--   Assuming both flags are set to <a>True</a>:
--   
--   <ol>
--   <li>If the contents type is an object, this will be <tt>{ tagkey:
--   tagvalue } &amp; contents</tt> (the same behavior as
--   <a>taggedObject</a>).</li>
--   <li>If the contents type is a nullable value, this well be <tt>{
--   tagkey: tagvalue, contentskey?: contents}</tt></li>
--   <li>Otherwise, this well be <tt>{ tagkey: tagvalue, contentskey:
--   contents}</tt></li>
--   </ol>
--   
--   If the first argument is <a>False</a>, will avoid case (1). If the
--   second argument is <a>False</a>, will avoid case (2).
--   
--   <pre>
--   case1 :: TSType_ p (Text, Int)
--   case1 = <a>TSType_</a> . <a>tsObject</a> $
--     (,) &lt;$&gt; <a>keyVal</a> True "name" fst (TSType_ <a>tsText</a>)
--         &lt;*&gt; <a>keyVal</a> True "age" snd (TSType_ <a>tsBoundedInteger</a>)
--   
--   case2 :: TSType_ p (Maybe Int)
--   case2 = <a>TSType_</a> $ <tt>tsNullable</tt> (<a>TSType_</a> <a>tsBoundedInteger</a>)
--   
--   case3 :: TSType_ p String
--   case3 = <a>TSType_</a> <a>tsString</a>
--   </pre>
--   
--   <pre>
--   <tt>ppType</tt> . <a>TSType_</a> $ <a>taggedValue</a> True True "tag" "something" "contents" case1
--   -- =&gt; { tag: "something" } &amp; { name: string, age: number }
--   
--   <tt>ppType</tt> . <a>TSType_</a> $ <a>taggedValue</a> True True "tag" "something" "contents" case2
--   -- =&gt; { tag: "something", contents?: number }
--   
--   <tt>ppType</tt> . <a>TSType_</a> $ <a>taggedValue</a> True True "tag" "something" "contents" case3
--   -- =&gt; { tag: "something", contents: string }
--   </pre>
taggedValue :: TaggedValueOpts -> Text -> TSType_ p a -> TSType p 'IsObj a
taggedNullary :: TaggedValueOpts -> Text -> a -> TSType_ p a

-- | A high-level data type describing the common pattern of a "tagged"
--   union (sum types in Haskell), where each branch comes in the form of
--   an object with a "tag" property with a string literal singleton, and
--   the rest of the object is the contents. We would store an <tt>Either
--   Int Bool</tt> as, say, <tt>{ tag: <a>Left</a>, contents: number } | {
--   tag: <a>Right</a>, contents: boolean }</tt>.
--   
--   Meant to be constructed using <a>taggedBranch</a> and other
--   <tt>Decide</tt> combinators.
newtype TaggedBranches p a
TaggedBranches :: DecAlt1 (Branch p) a -> TaggedBranches p a
[getTaggedBranches] :: TaggedBranches p a -> DecAlt1 (Branch p) a
data Branch p a
Branch :: Text -> Lift (TSType_ p) a -> Branch p a
[branchTag] :: Branch p a -> Text
[branchType] :: Branch p a -> Lift (TSType_ p) a
data TaggedValueOpts
TVOTagAndContents :: TagAndContents -> TaggedValueOpts
TVOTagIsKey :: TagIsKey -> TaggedValueOpts

-- | Create a singleton <a>TaggedBranches</a>, to be combined with
--   <tt>Decide</tt> combinators with others. Can also be used with
--   <a>tsUnions</a> if you want to combine a large number.
taggedBranch :: Text -> TSType_ p a -> TaggedBranches p a
mergeTB :: (a -> Either b c) -> (b -> a) -> (c -> a) -> TaggedBranches p b -> TaggedBranches p c -> TaggedBranches p a
emptyTaggedBranch :: Text -> a -> TaggedBranches p a
tsTaggedUnion :: TaggedValueOpts -> TaggedBranches p a -> TSType p 'NotObj a
tsTaggedUnions :: TaggedValueOpts -> (a -> NS I (b : bs)) -> NP (Op a) (b : bs) -> NP (TaggedBranches p) (b : bs) -> TSType p 'NotObj a
tsMaybe :: Text -> Text -> TSType_ p a -> TSType p 'NotObj (Maybe a)
instance GHC.Classes.Ord Typescript.Json.Union.TaggedValueOpts
instance GHC.Classes.Eq Typescript.Json.Union.TaggedValueOpts
instance GHC.Show.Show Typescript.Json.Union.TaggedValueOpts
instance GHC.Classes.Ord Typescript.Json.Union.TagIsKey
instance GHC.Classes.Eq Typescript.Json.Union.TagIsKey
instance GHC.Show.Show Typescript.Json.Union.TagIsKey
instance GHC.Classes.Ord Typescript.Json.Union.TagAndContents
instance GHC.Classes.Eq Typescript.Json.Union.TagAndContents
instance GHC.Show.Show Typescript.Json.Union.TagAndContents
instance Data.Functor.Invariant.Invariant (Typescript.Json.Union.TaggedBranches p)
instance Data.Default.Class.Default Typescript.Json.Union.TaggedValueOpts
instance Data.Default.Class.Default Typescript.Json.Union.TagIsKey
instance Data.Default.Class.Default Typescript.Json.Union.TagAndContents
instance Data.Functor.Invariant.Invariant (Typescript.Json.Union.Branch p)

module Typescript.Json
data TSType :: Nat -> IsObjType -> Type -> Type
data TSTypeF :: Nat -> IsObjType -> [Type] -> [Maybe Type] -> Type -> Type
data EnumLit
ELString :: Text -> EnumLit
ELNumber :: Scientific -> EnumLit
data TSType_ p a
TSType_ :: TSType p k a -> TSType_ p a
[unTSType_] :: TSType_ p a -> TSType p k a
data TSTypeF_ p as es b
TSTypeF_ :: TSTypeF p k as es b -> TSTypeF_ p as es b
[unTSTypeF_] :: TSTypeF_ p as es b -> TSTypeF p k as es b

-- | Wrap a type in a name, in a way that preserves <tt>k</tt> (whether or
--   not the type is an object literal).
tsNamed :: Text -> TSType p k a -> TSNamed p k '[] '[] a

-- | Wrap a type in a name.
--   
--   When printing this type, only the name will appear. However, when
--   generating exports (<a>typeExports</a>, <tt>typeExportsF</tt>), these
--   named types will be extracted and de-duplicated to the top level.
--   
--   If the same name appears twice within a type, it must describe the
--   same type underneath. Otherwise, behavior is undefined.
tsNamed_ :: Text -> TSType_ p a -> TSNamed_ p '[] '[] a
ppType :: TSType 'Z k a -> Doc x
ppType_ :: TSType_ 'Z a -> Doc x
ppNamed :: TSNamed 'Z k as es a -> Doc x
ppNamed_ :: TSNamed_ 'Z as es a -> Doc x
typeExports' :: Vec p Text -> TSType p k a -> Doc x
typeExports :: TSType 'Z k a -> Doc x
typeExports_ :: TSType_ 'Z a -> Doc x
namedTypeExports' :: Vec p Text -> TSNamed p k as es a -> Doc x
namedTypeExports :: TSNamed 'Z k as es a -> Doc x
namedTypeExports_ :: TSNamed_ 'Z as es a -> Doc x
encodeType :: TSType 'Z k a -> a -> ByteString
encodeTypeStrict :: TSType 'Z k a -> a -> ByteString
typeToValue :: TSType 'Z k a -> a -> Value
decodeType :: TSType 'Z k a -> ByteString -> Either (ParseError ParseErr) a
decodeTypeStrict :: TSType 'Z k a -> ByteString -> Either (ParseError ParseErr) a
parseType :: forall k a. () => TSType 'Z k a -> Parse a

module Typescript.Json.Generics
class GTSType (f :: Type -> Type)
gtoTSType :: GTSType f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> TSType_ p (f x)
data TSOpts
TSOpts :: (String -> Text) -> Bool -> MakeMaybe -> Bool -> (String -> Text) -> TaggedValueOpts -> Mutability -> (SomeTypeRep -> Text) -> TSOpts
[tsoFieldModifier] :: TSOpts -> String -> Text

-- | If <a>False</a>, turns all immediate Maybe fields into optional
--   fields. If <a>True</a>, keeps the field required.
[tsoPreserveMaybe] :: TSOpts -> Bool

-- | Turn a <tt>a</tt> into a <tt>Maybe a</tt>, used to fill in top-level
--   Maybe fields or if <a>tsoPreserveMaybe</a> is <a>True</a>.
[tsoMakeMaybe] :: TSOpts -> MakeMaybe

-- | When assigning fields, if a type is nullable (null is assignable to
--   it, or it's a union where null or undefined is a member) then turn it
--   into an optional field and strips the type of nulls. Note that this
--   will inline any named definitions if the type is nullable.
[tsoCollapseNullable] :: TSOpts -> Bool
[tsoConstructorModifier] :: TSOpts -> String -> Text
[tsoSumOpts] :: TSOpts -> TaggedValueOpts
[tsoReadOnlyFields] :: TSOpts -> Mutability
[tsoTypeNameModifier] :: TSOpts -> SomeTypeRep -> Text
class GTSSum (f :: Type -> Type)
gtsSum :: GTSSum f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> TaggedBranches p (f x)
class (forall p b. Applicative (t p b)) => GTSProduct (t :: Nat -> Type -> Type -> Type) (f :: Type -> Type) | f -> t
gtsProduct :: GTSProduct t f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> (a -> f x) -> t p a (f x)
class GTSTypeF (f :: Type -> Type)
gtoTSTypeF :: GTSTypeF f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> TSTypeF_ p '[a] '[ 'Nothing] (f a)
class GTSSumF (f :: Type -> Type)
gtsSumF :: GTSSumF f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> TSType p k a -> TaggedBranches p (f a)
class (forall p b. Applicative (t p b)) => GTSProductF (t :: Nat -> Type -> Type -> Type) (f :: Type -> Type) | f -> t
gtsProductF :: GTSProductF t f => TSOpts -> NP (TSType_ p) (LeafTypes f) -> (b -> f a) -> TSType p k a -> t p b (f a)
class GTSEnum (f :: Type -> Type)
gtsNamedEnum :: GTSEnum f => EnumOpts -> TSNamed p 'NotObj '[] '[] (f x)
data EnumOpts
EnumOpts :: (String -> Text) -> (String -> Maybe EnumLit) -> EnumOpts
[eoSelector] :: EnumOpts -> String -> Text

-- | if Nothing, picked from free integers, starting from 0
[eoLiteral] :: EnumOpts -> String -> Maybe EnumLit
newtype MakeMaybe
MakeMaybe :: (forall p a. TSType_ p a -> TSType_ p (Maybe a)) -> MakeMaybe
[runMakeMaybe] :: MakeMaybe -> forall p a. TSType_ p a -> TSType_ p (Maybe a)

-- | "none" | { "some": x }
simpleMakeMaybe :: Text -> Text -> MakeMaybe
class ToTSType a
toTSType :: ToTSType a => TSType_ p a
toTSType :: (ToTSType a, Generic a, GTSType (MRep a), All ToTSType (LeafTypes (MRep a))) => TSType_ p a
genericToTSType :: forall a p. (Generic a, GTSType (MRep a)) => TSOpts -> NP (TSType_ p) (LeafTypes (MRep a)) -> TSType_ p a
genericToTSType_ :: forall a p. (Generic a, GTSType (MRep a), All ToTSType (LeafTypes (MRep a))) => TSOpts -> TSType_ p a
genericToTSNamed :: forall a p. (Typeable a, Generic a, GTSType (MRep a)) => TSOpts -> NP (TSType_ p) (LeafTypes (MRep a)) -> TSNamed_ p '[] '[] a
genericToTSNamed_ :: forall a p. (Typeable a, Generic a, GTSType (MRep a), All ToTSType (LeafTypes (MRep a))) => TSOpts -> TSNamed_ p '[] '[] a
genericToTSType1 :: forall f p a. (Typeable f, Generic1 f, GTSTypeF (MRep1 f)) => TSOpts -> NP (TSType_ p) (LeafTypes (MRep1 f)) -> TSType_ p a -> TSType_ p (f a)
genericToTSType1_ :: forall f p a. (Typeable f, Generic1 f, GTSTypeF (MRep1 f), All ToTSType (LeafTypes (MRep1 f))) => TSOpts -> TSType_ p a -> TSType_ p (f a)
genericToTSTypeF :: forall f p a. (Generic1 f, GTSTypeF (MRep1 f)) => TSOpts -> NP (TSType_ p) (LeafTypes (MRep1 f)) -> TSTypeF_ p '[a] '[ 'Nothing] (f a)
genericToTSTypeF_ :: forall f p a. (Generic1 f, GTSTypeF (MRep1 f), All ToTSType (LeafTypes (MRep1 f))) => TSOpts -> TSTypeF_ p '[a] '[ 'Nothing] (f a)
genericToTSNamedF :: forall f p a. (Typeable f, Generic1 f, GTSTypeF (MRep1 f)) => TSOpts -> NP (TSType_ p) (LeafTypes (MRep1 f)) -> TSNamed_ p '[a] '[ 'Nothing] (f a)
genericToTSNamedF_ :: forall f p a. (Typeable f, Generic1 f, GTSTypeF (MRep1 f), All ToTSType (LeafTypes (MRep1 f))) => TSOpts -> TSNamed_ p '[a] '[ 'Nothing] (f a)
genericNamedEnum :: forall a p. (Generic a, GTSEnum (Rep a)) => EnumOpts -> TSNamed p 'NotObj '[] '[] a
type family (as :: [k]) ++ (bs :: [k]) :: [k]
splitNP :: NP p as -> NP f (as ++ bs) -> (NP f as, NP f bs)
mfrom :: forall a x. Generic a => a -> MRep a x
mto :: forall a x. Generic a => MRep a x -> a
type MRep a = PullMaybe (Rep a)
type MRep1 a = PullMaybe (Rep1 a)
type family PullMaybe (f :: Type -> Type) :: Type -> Type
newtype KM1 i a x
KM1 :: Maybe a -> KM1 i a x
[unKM1] :: KM1 i a x -> Maybe a
data FooBar a
FooBar :: Foo -> Bar -> a -> FooBar a
data List a
LNil :: List a
LCons :: a -> List a -> List a
instance GHC.Generics.Generic Typescript.Json.Generics.Natt
instance GHC.Generics.Generic1 Typescript.Json.Generics.List
instance GHC.Generics.Generic (Typescript.Json.Generics.List a)
instance GHC.Generics.Generic1 Typescript.Json.Generics.Moobie
instance GHC.Generics.Generic (Typescript.Json.Generics.Moobie a)
instance GHC.Generics.Generic1 Typescript.Json.Generics.FooBar
instance GHC.Generics.Generic (Typescript.Json.Generics.FooBar a)
instance GHC.Generics.Generic Typescript.Json.Generics.Bar
instance GHC.Generics.Generic Typescript.Json.Generics.Foo
instance forall k1 (i :: k1) a k2 (x :: k2). GHC.Show.Show a => GHC.Show.Show (Typescript.Json.Generics.KM1 i a x)
instance Typescript.Json.Generics.ToTSType Typescript.Json.Generics.Bar
instance Typescript.Json.Generics.ToTSType Typescript.Json.Generics.Foo
instance (GHC.TypeLits.KnownSymbol nm, Typescript.Json.Generics.GTSEnumBranches f) => Typescript.Json.Generics.GTSEnum (GHC.Generics.M1 GHC.Generics.D ('GHC.Generics.MetaData nm a b c) f)
instance Typescript.Json.Generics.GTSEnumBranches GHC.Generics.V1
instance (Typescript.Json.Generics.GTSEnumBranches f, Typescript.Json.Generics.GTSEnumBranches g, Data.Type.Nat.InlineInduction (Data.Type.Nat.Plus (Typescript.Json.Generics.Cardinality f) (Typescript.Json.Generics.Cardinality g))) => Typescript.Json.Generics.GTSEnumBranches (f GHC.Generics.:+: g)
instance GHC.TypeLits.KnownSymbol ctr => Typescript.Json.Generics.GTSEnumBranches (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons ctr p q) GHC.Generics.U1)
instance Data.Default.Class.Default Typescript.Json.Generics.EnumOpts
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSProductF t f, Typescript.Json.Generics.GTSProductF t g, Typescript.Json.Generics.WrapProduct k t) => Typescript.Json.Generics.GTSTypeF (f GHC.Generics.:*: g)
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSProductF t f, Typescript.Json.Generics.GTSProductF t g) => Typescript.Json.Generics.GTSProductF t (f GHC.Generics.:*: g)
instance GHC.TypeLits.KnownSymbol k => Typescript.Json.Generics.GTSProductF Typescript.Json.Collection.ObjectProps (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just k) a b c) (GHC.Generics.K1 i r))
instance forall k1 (k2 :: GHC.Types.Symbol) (a :: GHC.Generics.SourceUnpackedness) (b :: GHC.Generics.SourceStrictness) (c :: GHC.Generics.DecidedStrictness) (i :: k1) r. GHC.TypeLits.KnownSymbol k2 => Typescript.Json.Generics.GTSProductF Typescript.Json.Collection.ObjectProps (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just k2) a b c) (Typescript.Json.Generics.KM1 i r))
instance Typescript.Json.Generics.GTSTypeF f => Typescript.Json.Generics.GTSProductF Typescript.Json.Collection.TupleVals (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel 'GHC.Maybe.Nothing a b c) f)
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSSumF f, Typescript.Json.Generics.GTSSumF g) => Typescript.Json.Generics.GTSTypeF (f GHC.Generics.:+: g)
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSSumF f, Typescript.Json.Generics.GTSSumF g) => Typescript.Json.Generics.GTSSumF (f GHC.Generics.:+: g)
instance GHC.TypeLits.KnownSymbol constr => Typescript.Json.Generics.GTSSumF (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) GHC.Generics.U1)
instance (GHC.TypeLits.KnownSymbol constr, Typescript.Json.Generics.GTSTypeF f) => Typescript.Json.Generics.GTSSumF (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) f)
instance Typescript.Json.Generics.GTSTypeF f => Typescript.Json.Generics.GTSTypeF (GHC.Generics.M1 GHC.Generics.D e f)
instance Typescript.Json.Generics.GTSTypeF f => Typescript.Json.Generics.GTSTypeF (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel s a b c) f)
instance Typescript.Json.Generics.GTSTypeF f => Typescript.Json.Generics.GTSTypeF (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) f)
instance Typescript.Json.Generics.GTSTypeF GHC.Generics.Par1
instance Typescript.Json.Generics.GTSTypeF (GHC.Generics.K1 i x)
instance forall k (i :: k) x. Typescript.Json.Generics.GTSTypeF (Typescript.Json.Generics.KM1 i x)
instance Typescript.Json.Generics.GTSTypeF GHC.Generics.U1
instance Typescript.Json.Generics.GTSTypeF GHC.Generics.V1
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSProduct t f, Typescript.Json.Generics.GTSProduct t g, Typescript.Json.Generics.WrapProduct k t) => Typescript.Json.Generics.GTSType (f GHC.Generics.:*: g)
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSProduct t f, Typescript.Json.Generics.GTSProduct t g) => Typescript.Json.Generics.GTSProduct t (f GHC.Generics.:*: g)
instance GHC.TypeLits.KnownSymbol k => Typescript.Json.Generics.GTSProduct Typescript.Json.Collection.ObjectProps (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just k) a b c) (GHC.Generics.K1 i r))
instance forall k1 (k2 :: GHC.Types.Symbol) (a :: GHC.Generics.SourceUnpackedness) (b :: GHC.Generics.SourceStrictness) (c :: GHC.Generics.DecidedStrictness) (i :: k1) r. GHC.TypeLits.KnownSymbol k2 => Typescript.Json.Generics.GTSProduct Typescript.Json.Collection.ObjectProps (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just k2) a b c) (Typescript.Json.Generics.KM1 i r))
instance Typescript.Json.Generics.GTSType f => Typescript.Json.Generics.GTSProduct Typescript.Json.Collection.TupleVals (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel 'GHC.Maybe.Nothing a b c) f)
instance Typescript.Json.Generics.WrapProduct 'Typescript.Json.Types.IsObj Typescript.Json.Collection.ObjectProps
instance Typescript.Json.Generics.WrapProduct 'Typescript.Json.Types.NotObj Typescript.Json.Collection.TupleVals
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSSum f, Typescript.Json.Generics.GTSSum g) => Typescript.Json.Generics.GTSType (f GHC.Generics.:+: g)
instance (Data.SOP.Constraint.All Data.SOP.Constraint.Top (Typescript.Json.Generics.LeafTypes f), Typescript.Json.Generics.GTSSum f, Typescript.Json.Generics.GTSSum g) => Typescript.Json.Generics.GTSSum (f GHC.Generics.:+: g)
instance GHC.TypeLits.KnownSymbol constr => Typescript.Json.Generics.GTSSum (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) GHC.Generics.U1)
instance (GHC.TypeLits.KnownSymbol constr, Typescript.Json.Generics.GTSType f) => Typescript.Json.Generics.GTSSum (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) f)
instance Typescript.Json.Generics.ToTSType GHC.Types.Int
instance Typescript.Json.Generics.ToTSType GHC.Types.Double
instance Typescript.Json.Generics.ToTSType GHC.Types.Bool
instance Typescript.Json.Generics.ToTSType GHC.Types.Ordering
instance Typescript.Json.Generics.ToTSType Data.Text.Internal.Text
instance Typescript.Json.Generics.ToTSType a => Typescript.Json.Generics.ToTSType [a]
instance Typescript.Json.Generics.ToTSType a => Typescript.Json.Generics.ToTSType (GHC.Maybe.Maybe a)
instance Typescript.Json.Generics.GTSType f => Typescript.Json.Generics.GTSType (GHC.Generics.M1 GHC.Generics.D ('GHC.Generics.MetaData nm a b c) f)
instance Typescript.Json.Generics.GTSType f => Typescript.Json.Generics.GTSType (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel s a b c) f)
instance Typescript.Json.Generics.GTSType f => Typescript.Json.Generics.GTSType (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons constr a b) f)
instance Typescript.Json.Generics.GTSType (GHC.Generics.K1 i a)
instance forall k (i :: k) a. Typescript.Json.Generics.GTSType (Typescript.Json.Generics.KM1 i a)
instance Typescript.Json.Generics.GTSType GHC.Generics.U1
instance Typescript.Json.Generics.GTSType GHC.Generics.V1
instance Data.Default.Class.Default Typescript.Json.Generics.TSOpts
